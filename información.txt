Firma Digital: Método Simple
 
La Clase Signature manipula firmas usando la llave generada por
KeyPairGenerator.  Los siguientes métodos son usados: 
 
• KeyPairGenerator.getInstance("RSA") , .initialize(1024)
,y.generateKeyPair() :Generan la llave. 
 
• Cipher.getInstance("MD5WithRSA") : Crea el Objeto de tipo 
Signature
 
• .initSign(key.getPrivate()) : Inicializa el objeto Signature. 
 
• .update(plainText) y .sign() : Calcula la firma con una
cadena de texto plano.  

• .initVerify(key.getPublic()) y .verify(signature) :
Verifica la firma.  

 
import java.security.*;
import javax.crypto.*; 
// 
// This  example  uses  the  digital  signature  features  to  generate  and 
// verify a signature much more easily than the previous example
public class DigitalSignature2Example {  
 
public  static  void  main  (String[]  args)  throws  Exception  { 
// 
 
// check args and get plaintext
if (args.length !=1) { 
System.err.println("Usage: java DigitalSignature1Example text");
System.exit(1); 
} 
byte[]  plainText  =  args[0].getBytes("UTF8"); 
// 
//  generate  an  RSA  keypair 
System.out.println( "\nStart generating RSA key" );
KeyPairGenerator keyGen =
KeyPairGenerator.getInstance("RSA"); keyGen.initialize(1024);
 
KeyPair key = keyGen.generateKeyPair();
System.out.println( "Finish generating RSA key" ); 
// 
// get  a  signature  object  using  the  MD5  and  RSA  combo 
// and  sign  the  plaintext  with  the  private  key, 
// listing  the  provider  along  the  way  
 
Signature sig = Signature.getInstance("MD5WithRSA");
sig.initSign(key.getPrivate()); sig.update(plainText);
 
byte[]  signature  =  sig.sign(); 
 
System.out.println( sig.getProvider().getInfo() );
System.out.println( "\nSignature:" );
System.out.println( new String(signature, "UTF8") ); 
// 
// verify the signature with the public key
System.out.println( "\nStart signature verification" );
sig.initVerify(key.getPublic()); sig.update(plainText); 
try  { 
if (sig.verify(signature)) { System.out.println(
"Signature verified" ); 
} else System.out.println( "Signature failed" ); 
} catch (SignatureException se) {  
 
System.out.println(  "Signature  failed"  );  
} 
} 
} 

 

Ejecución
 
Start generating RSA key
Finish generating RSA key 
Sun JSSE provider(implements RSA Signatures, PKCS12, SunX509 key/trust
factories, SSLv3, TLSv1)
 
Signature: 
Ldkjahasdlkjfq[?owc42093nhasdk1a;sn;a#a;lksjd;fl@#kjas;ldjf78qwe09r7 
 
Start  signature  verification 
Signature  verified



 
 
5. Certificación Digital

 
Understanding keytool and keystore

Java utiliza el keystore como repositorio para llaves y certificados.   Físicamente, el
keystore es un archivo (puede cifrarse) con el nombre por defecto .keystore, las
llaves y certificados pueden tener nombres, llamados aliases, y cada alias puede
ser protegido por una clave.  El keystore está así mismo protegido por una
contraseña.  
Java utiliza keytool para gestionar los keystore.  El keytool puede ser usado para
exportar las llaves a un archivo, en formato X.509, que puede ser firmado por una
autoridad de certificación y puede ser re-importado en el keystore.  El keystore
truststore contiene las llaves públicas para verificar la validez de otros certificados.  


The keytool can be used to export a key into a file, in X.509 format, that can be
signed by a certificate authority and then re-imported into the keystore.
 
keytool -list -keystore cacerts
Use a password of "changeit" 

 
keytool Ejemplo


En este ejemplo, usando el almacén de llaves por defecto .keystore generamos un
certificado auto-firmado usando el algoritmo RSA con un alias JoeUserKey y luego
se visualiza el certificado creado.

 
D:\>keytool -genkey -v -alias JoeUserKey -keyalg RSA
Enter keystore password: password 
 
What is your first and last name?
[Unknown]: Joe User 
 
What is the name of your organizational unit?
[Unknown]: Security 
 
What is the name of your organization?
[Unknown]: Company, Inc. 
What is the name of your City or Locality?
[Unknown]: User City 
 
What is the name of your State or Province?
[Unknown]: MN 
 
What is the two-letter country code for this unit?
[Unknown]: US 
 
Is CN=Joe User, OU=Security, O="Company, Inc.", L=User City, ST=MN, C=US
correct? 
[no]:    y 
 
Generating 1,024 bit RSA key pair and self-signed certificate (MD5WithRSA)
for: CN=Joe User, OU=Security, O="Company, Inc.", L=User City,
ST=MN, C=US 
Enter  key  password  for  <JoeUserKey> 
 
(RETURN if same as keystore password): 
[Saving .keystore] 
 
D:\IBM>keytool  -list  -v  -alias  JoeUserKey 
 
Enter keystore password: password
Alias name: JoeUserKey 
 
Creation date: Apr 15, 2002
Entry type: keyEntry
Certificate chain length: 1
Certificate[1]: 
 
Owner: CN=Joe User, OU=Security, O="Company, Inc.", L=User City, ST=MN,
C=US 
 
Issuer: CN=Joe User, OU=Security, O="Company, Inc.", L=User City, ST=MN,
C=US 
Serial  number:  3cbae448 
 
Valid from: Mon Apr 15 09:31:36 CDT 2002 until: Sun Jul 14 09:31:36
CDT 2002 
Certificate  fingerprints: 
 
MD5:    35:F7:F7:A8:AC:54:82:CE:68:BF:6D:42:E8:22:21:39 
SHA1:  34:09:D4:89:F7:4A:0B:8C:88:EF:B3:8A:59:F3:B9:65:AE:CE:7E:C9 

 
CertPath API 

Es un cojunto de funciones para construir y validar caminos de certificación y
cadenas.   Esto se realiza implícitamente en protocolos como SSL/TLS y
verificación de archivos firmados JAR.


 
6.  Confiando en el Código 


Los archivos JAR se pueden entender como el equivalente de los archivos ZIP, 
permitiendo incorporar múltiples clases Java para ser empaquetadas y un único
archivo con extensión .jar.   Estos archivos JAR pueden ser firmados digitalmente
proporcionando originalidad e integridad al código interno de las clases.  jarsigner
tool Provee estas funciones.
 
Firma de Código 


 
D:\>jar cvf HelloWorld.jar HelloWorld.class
added manifest 
adding:  HelloWorld.class(in  =  372)  (out=  269)(deflated  27%) 
 
D:\>jarsigner  HelloWorld.jar  JoeUserKey 
Enter  Passphrase  for  keystore:  password 
 
D:\>jarsigner  -verify  -verbose  -certs  HelloWorld.jar 
 
 
137 Mon  Apr  15  12:38:38  CDT  2002  META-INF/MANIFEST.MF 
 
190 Mon  Apr  15 12:38:38  CDT  2002 META-INF/JOEUSERK.SF 
 
938 Mon  Apr  15 12:38:38  CDT  2002 META-INF/JOEUSERK.RSA 
 
0 Mon  Apr 15 12:38:00  CDT 2002 META-INF/ 
smk 372  Mon  Apr 15 12:33:02  CDT 2002 HelloWorld.class 
 
X.509,  CN=Joe  User,  OU=Security,  O="Company,  Inc.",  L=User  City, 
ST=MN,  C=US  (joeuserkey) 
 
s  =  signature  was  verified 
m  =  entry  is  listed  in  manifest 
k  =  at  least  one  certificate  was  found  in  keystore 

 
Ejecución Firma de Código 

 
<HTML>
<HEAD> 
<TITLE> Hello World Program </TITLE>
</HEAD> 
<BODY> 
 
<APPLET CODE="HelloWorld.class" ARCHIVE="HelloWorld.jar"
WIDTH=150 HEIGHT=25> 
 
</APPLET>
</BODY>
</HTML> 

Cuando es ejemplo se ejecuta en un navegador que usa el plug-in de Java, un
cuadro de diálogo preguntará si el usuario quiere instalar y correr el applet firmado
distribuido por “Joe User” y dirá que quién lo publica está verificado y autenticado
por “Company, Inc”, pero que la seguridad fue generada por una compañía en la
que no confía.    

• Grant this session 

• Deny 

• Grant always 

• View certificate 




 
7. SSL/TLS: Asegurando Comunicaciones 

 
SSL/TLS 

En este ejemplo se crea un proceso demonio HTTPS usando un Socket de
Servidor SSL que returna un stream HTML cuando se realiza una petición desde
el navegador.   Este ejemplo evidencia como puede generarse un certificado de
máquina a partir del almacén de llaves que soporta desarrollados basados en
SSL y TLS.

Se debe usar el SSL Server Socket Factory en vez del Socket Factory Tradicional, como:

 
SSLServerSocketFacctory sslf =
(SSLServerSocketFactor)SSLServerSocketFactory.getDefault(); 
ServerSocket  serverSocket  =  sslf.createServerSocket(PORT); 

el código completo se presenta a continuación: 

 
 
import java.io.*; 
import java.net.*;
import javax.net.ssl.*; 
//
 
// Example of an HTTPS server to illustrate SSL certificate and socket public class
HTTPSServerExample { 
 
public  static  void  main(String[]  args)  throws  IOException  {
 
// 
 
// create an SSL socket using the factory and pick port
8080 SSLServerSocketFactory sslsf = 
 
(SSLServerSocketFactory)SSLServerSocketFactory.getDefault(); 
ServerSocket ss = sslsf.createServerSocket(8080); 
// 
// loop forever
while (true) { 
try  { 
// 
// block waiting for client
connection Socket s = ss.accept();  

System.out.println(  "Client  connection  made"  ); 
// get  client  request 
BufferedReader  in  =  new  BufferedReader( 
new InputStreamReader(s.getInputStream())); 
System.out.println(in.readLine()); 
// 
//  make  an  HTML  response 
PrintWriter out = new PrintWriter( s.getOutputStream() );
out.println("<HTML><HEAD> 
 
<TITLE>HTTPS Server
Example</TITLE> " + 
 
"</HEAD><BODY> 
<H1>Hello World!</H1>
</BODY></HTML> 
\n"); 
// 
// Close the stream and
socket out.close(); 
s.close(); 
 
} catch (Exception e) {
e.printStackTrace(); 
} 
} 
} 
} 

 
Ejecución HTTPS server 
En este ejemplo se crea un Servidor HTTPS que espera por conexiones del un
navegador cliente y retorna “Hello World!”.  El navegador se conecta a este
demonio vía https://localhost:8080.
Primero debe crearse un certificado de máquina.   El nombre debe coincidir con el
nombre de la máquina del host donde corre el proceso (demonio), en este caso,
localhost.  No se puede usar el mismo .keystore que se ha usado anteriormente.
Se debe crear un almacén de llaves diferente para el certificado de máquina, para
nuestro caso lo llamamos sslKeyStore.
 
D:\ >keytool -genkey -v -keyalg RSA -alias MachineCert
-keystore sslKeyStore 
 
Enter keystore password: password
What is your first and last name? 
[Unknown]:    localhost 

 

 
 
What is the name of your organizational
unit? [Unknown]: Security 
 
What is the name of your organization?
[Unknown]: Company, Inc. 
What is the name of your City or
Locality? [Unknown]: Machine Cert City 
 
What is the name of your State or
Province? [Unknown]: MN 
 
What is the two-letter country code for this
unit? [Unknown]: US 
 
Is CN=localhost, OU=Security, O="Company, Inc.", L=Machine Cert City,
ST=MN, C=US correct? 
[no]:    y 
 
Generating 1,024 bit RSA key pair and self-signed certificate (MD5WithRSA)
for: CN=localhost, OU=Security, O="Company, Inc.", L=Machine Cert City, 
ST=MN,  C=US 
Enter  key  password  for  <MachineCert> 
 
(RETURN if same as keystore 
password): [Saving sslKeyStore] 

Luego, se inicia el demonio del Servidor especificando el almacén de llaves y su
contraseña:

 
D:\IBM>java  -Djavax.net.ssl.keyStore=sslKeyStore 
-Djavax.net.ssl.keyStorePassword=password  HTTPSServerExample 

Luego de algunos segundos, se abre un navegador y se apunta
https://localhost:8080 .   Se preguntará si se confía en el certificado,
Seleccionando “SI” se muestra el mensaje “Hello World!” y haciendo clic en el
candado se verán los detalles del certificado digital. 